<!DOCTYPE html>
<meta charset="utf-8" />
<meta name=help href="https://privacycg.github.io/storage-partitioning/">
<title>Storage Manager: partitioned usage estimate for indexedDB test</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/dispatcher/dispatcher.js"></script>
<script src="/common/utils.js"></script>
<script src="./helpers.js"></script>
<script src="../IndexedDB/support-promises.js"></script>

<body>
  <script>
    async function runTest(test, alt_context, cross_site) {
      let usage_details = {};
      let alt_origin = "https://{{hosts[alt][]}}:{{ports[https][0]}}";
      // We use 100KB here because db compaction usually happens every few MB
      // 100KB is large enough to avoid a false positive (small amounts of
      // metadata getting written for some random reason), and small enough to
      // avoid compaction with a reasonably high probability.
      const write_size = 1024 * 100;
      const object_store_name = token();
      const db_name = self.location.pathname;

      await indexedDB.deleteDatabase(db_name);
      const db = await createDB(db_name, object_store_name, test);

      usage_details.before_write =
        (await navigator.storage.estimate()).usageDetails.indexedDB || 0;

      const transaction = db.transaction(object_store_name, 'readwrite');
      const value_to_store = largeValue(write_size, Math.random() * 255);
      transaction.objectStore(object_store_name).add(value_to_store, 1);

      await transactionPromise(transaction);

      usage_details.after_write =
        (await navigator.storage.estimate()).usageDetails.indexedDB || 0;
      assert_less_than(usage_details.before_write, usage_details.after_write);

      switch (alt_context) {
        case "iframe":
          const iframe = document.createElement('iframe');
          iframe.src = (cross_site ? `${alt_origin}/storage/` : "") +
            "resources/partitioned-estimate-usage-details-indexeddb-" +
            "helper-frame.html";
          document.body.appendChild(iframe);
          test.add_cleanup(async () => { await iframe.remove(); });
          break;
        case "window":
          const src = (cross_site ? `${alt_origin}/storage/` : "") +
            "resources/partitioned-estimate-usage-details-indexeddb-" +
            "helper-frame.html";
          const second_window = window.open(src, "", "noopener=false");
          test.add_cleanup(async () => { await second_window.close(); });
          break;
        default:
          break;
      }

      await new Promise(function (resolve) {
        window.addEventListener("message", (event) => {
          usage_details.alt_context = event.data;
          assert_less_than(usage_details.alt_context.before_write,
            usage_details.alt_context.after_write);
          resolve();
        }, { once: true });
      });

      if (cross_site) {
        assert_less_than(usage_details.alt_context.before_write,
          usage_details.after_write);
      } else {
        assert_greater_than_equal(usage_details.alt_context.before_write,
          usage_details.after_write);
      }

      await db.close();
    }

    promise_test(async (test) => {
      await runTest(test, "iframe", /*cross_site=*/0);
    }, '1. Test Storage Manager: partitioned usage estimate for indexedDB.');

    promise_test(async (test) => {
      await runTest(test, "iframe", /*cross_site=*/1);
    }, '2. Test Storage Manager: partitioned usage estimate for indexedDB.');

    promise_test(async (test) => {
      await runTest(test, "window", /*cross_site=*/0);
    }, '3. Test Storage Manager: partitioned usage estimate for indexedDB.');

    promise_test(async (test) => {
      await runTest(test, "window", /*cross_site=*/1);
    }, '4. Test Storage Manager: partitioned usage estimate for indexedDB.');
  </script>
</body>

</html>
